# 1. Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.
**-> 정수 25를 10진수, 2진수, 8진수, 16진수로 표현한 심볼릭 상수를 정의하라.**
답: 
   ```
DEC25   EQU 25        ; 10진수
BIN25   EQU 11001b    ; 2진수
OCT25   EQU 31o       ; 8진수
HEX25   EQU 19h       ; 16진수
```
# 2. Find out, by trial and error, if a program can have multiple code and data segments.
**-> 프로그램에서 여러 개의 코드 세그먼트와 데이터 세그먼트를 사용할 수 있는지 직접 실험해보라.**

   답:  어셈블러/링커에 따라 다르지만, 보통 MASM 같은 경우 여러 세그먼트 사용이 가능하다.

# 3. Create a data definition for a doubleword that stored it in memory in big endian format.
**-> 메모리에 big endian 방식으로 저장되는 4바이트(doubleword) 데이터를 정의하라.**
   
답: MyDword BYTE 12h, 34h, 56h, 78h ; 빅엔디안: 상위 바이트가 먼저 저장됨

# 4. Find out if you can declare a variable of type DWORD and assign it a negative value. What does this tell you about the assembler’s type checking?
**-> DWORD(4바이트) 타입 변수에 음수를 할당할 수 있는지 실험해보고, 어셈블러의 타입 체크 방식에 대해 생각해보라.**

   답: 음수 할당 가능. 어셈블러는 타입 체크가 엄격하지 않으며, 해당 값을 2의 보수로 저장함.

# 5. Write a program that contains two instructions: (1) add the number 5 to the EAXregister, and (2) add 5 to the EDX register. Generate a listingfile and examine themachine code generated by the assembler. What differences, if any, did you find between the two instructions?

**-> EAX 레지스터에 5를 더하는 명령과 EDX 레지스터에 5를 더하는 명령을 각각 작성한 뒤, 생성된 머신 코드를 비교해 어떤 차이가 있는지 살펴보라.**

   답: 
```add eax, 5
add edx, 5
```
# 6. Given the number 456789ABh, list out its byte values in little-endian order.
**-> 16진수 456789ABh 값을 리틀엔디안 방식으로 바이트 단위로 나열하라.**

답: AB 89 67 45
 
# 7. Declare an array of 120 uninitialized unsigned doubleword values.
**-> 초기화하지 않은 120개의 unsigned doubleword(4바이트) 배열을 선언하라.**  

 답: Array DWORD 120 DUP(?)

 
# 8. Declare an array of byte and initialize it to the first 5 letters of the alphabet.
**-> BYTE(1바이트) 배열을 선언하고, 알파벳 처음 5글자(A, B, C, D, E)로 초기화하라.**

   답: Letters BYTE 'A','B','C','D','E'
 
# 9. Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)
**->32비트 부호 있는 정수형 변수를 선언하고, 가질 수 있는 가장 작은 음수 값(10진수)으로 초기화하라. (힌트: 1장에서 정수의 범위를 참고하라.)**
   
답: MinInt SDWORD -2147483648
 
# 10. Declare an unsigned 16-bit integer variable named wArray that uses three initial izers.
**-> 이름이 wArray인 unsigned 16비트 정수 변수에 세 개의 초기값을 할당하여 선언하라.**

   답: wArray WORD 1, 2, 3
 
# 11. Declare a string variable containing the name of your favorite color. Initialize it as a nullterminated string.
**-> 좋아하는 색상 이름을 담은 문자열 변수를 선언하고, 문자열 끝에 널 문자(0)를 붙여라.**
   
답: ColorName BYTE "blue", 0

# 12. Declare an uninitialized array of 50 signed doublewords named dArray.
**-> 초기화하지 않은 50개의 signed doubleword(4바이트) 배열 dArray를 선언하라.**
   
답: dArray SDWORD 50 DUP(?)

# 13. Declare a string variable containing the word “TEST” repeated 500 times.
**-> "TEST"라는 단어를 500번 반복해서 담는 문자열 변수를 선언하라.**

   답: RepeatStr BYTE 500 DUP("TEST")
 
# 14. Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero.
-**> 20개의 unsigned byte(1바이트) 배열 bArray를 선언하고, 모든 요소를 0으로 초기화하라.**

   답: bArray BYTE 20 DUP(0)

 # 15. Show the order of individual bytes in memory (lowest to highest) for the following double
word variable:

    val1 DWORD 87654321h
**-> 아래의 더블워드 변수(val1 DWORD 87654321h)에 대해, 메모리에서 개별 바이트의 순서를 (가장 낮은 주소에서 가장 높은 주소로) 보여라.**
   
답: 21 43 65 87


